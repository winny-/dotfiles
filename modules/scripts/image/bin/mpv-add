#!/usr/bin/env python3

import time
import json
import asyncio
import click
from pathlib import Path
from functools import wraps


class MPVClient:

    TIMEOUT_NS: int = 5 * 1000**3

    def __init__(self, socketpath: Path):
        self.socketpath = socketpath
        self._reader: asyncio.StreamReader | None = None
        self._writer: asyncio.StreamWriter | None = None
        self._request_counter: int = 1

    async def connect(self):
        self._reader, self._writer = await asyncio.open_unix_connection(
            self.socketpath,
        )

    async def close(self):
        if self._writer is not None:
            self._writer.close()
            await self._writer.wait_closed()
        self._reader = self._writer = None

    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.close()

    async def message(self, obj: dict) -> dict:
        """Send a message and wait for a response.

        A request_id is automatically generated and any pre-exising request_id
        field is overwritten.  The returned dictionary has its request_id
        removed.

        This code checks for errors and may raise MPVClient.IPCReplyError.

        On timeout (see MPVClient.TIMEOUT_NS), a MPVClient.IPCTimeoutError
        is raised.

        """
        if self._writer is None or self._reader is None:
            raise RuntimeError('No connection')
        obj_copy = dict(obj)
        obj_copy['request_id'] = request_id = self._request_counter
        self._request_counter += 1
        b = (json.dumps(obj_copy) + '\n').encode('utf-8')
        self._writer.write(b)
        await self._writer.drain()

        timeout = time.time_ns() + self.TIMEOUT_NS
        while True:
            current = time.time_ns()
            if timeout < current:
                # TODO math doesn't seem right here, though timeout works.
                raise MPVClient.IPCTimeoutError(current - timeout)
            try:
                reply_s = await asyncio.wait_for(self._reader.readline(),
                                                 timeout=.25)
            except TimeoutError:
                continue
            reply_obj = json.loads(reply_s.decode('utf-8'))
            if not isinstance(reply_obj, dict):
                raise MPVClient.IPCReplyError(reply_obj)
            if reply_obj.get('request_id') != request_id:
                continue
            break

        if reply_obj.get('error') != 'success':
            raise MPVClient.IPCReplyError(reply_obj)
        del reply_obj['request_id']
        return reply_obj

    class IPCError(RuntimeError):
        pass

    class IPCTimeoutError(IPCError):
        def __init__(self, timeoutns):
            super().__init__('IPC timed out after {} ns'.format(timeoutns))
            self.timeoutns = timeoutns

    class IPCReplyError(IPCError):
        def __init__(self, reply):
            super().__init__('Bad MPV IPC Reply: {}'.format(reply))
            self.reply = reply


def coro(f):
    """https://github.com/pallets/click/issues/85#issuecomment-503464628"""
    @wraps(f)
    def wrapper(*args, **kwargs):
        return asyncio.run(f(*args, **kwargs))

    return wrapper


@click.command()
@click.argument('filename',
                nargs=-1,
                type=click.Path(exists=True, resolve_path=True))
# TODO validate path corresponds to a socket file.
@click.option('--socketpath',
              type=click.Path(exists=True, dir_okay=False),
              default=Path.home() / '.config/mpv/mpv.socket')
@coro
async def mpv_add(filename, socketpath):
    async with MPVClient(socketpath) as c:
        for f in filename:
            await c.message({
                'command': [
                    'loadfile',
                    f,
                    'append-play',
                ]
            })


if __name__ == '__main__':
    mpv_add()
