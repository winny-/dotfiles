#!/usr/bin/env python3

"""My Kobo runs KOReader.  Set up KOReader's Cloud Storage with the WebDAV URL
that this script prints out.  Then access the books to read over WebDAV.  Works
as a dead simple file server too.  Opens up firewalld because I always forget
the incantation.

This iteration was vibecoded with ChatGPT.  It works.  Whatever.
https://chatgpt.com/share/67fd3a4c-1cc0-800d-b682-eb71aea541d7

"""

import os
import sys
import socket
import signal
import subprocess
import click
import psutil
import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import unquote, urlparse
from xml.etree.ElementTree import Element, SubElement, tostring


ALLOWED_METHODS = ["GET", "HEAD", "OPTIONS", "PROPFIND"]


def make_propfind_response(path, base_url):
    is_dir = os.path.isdir(path)
    name = os.path.basename(path)
    stat = os.stat(path)
    response = Element("d:multistatus", {
        "xmlns:d": "DAV:",
    })

    def add_response(href, stat_path):
        res = SubElement(response, "d:response")
        SubElement(res, "d:href").text = href
        propstat = SubElement(res, "d:propstat")
        prop = SubElement(propstat, "d:prop")

        SubElement(prop, "d:displayname").text = os.path.basename(stat_path)
        SubElement(prop, "d:getcontentlength").text = str(os.path.getsize(stat_path)) if os.path.isfile(stat_path) else "0"
        SubElement(prop, "d:getlastmodified").text = datetime.datetime.utcfromtimestamp(
            os.path.getmtime(stat_path)).strftime('%a, %d %b %Y %H:%M:%S GMT')
        SubElement(prop, "d:resourcetype").append(Element("d:collection") if os.path.isdir(stat_path) else Element(""))

        SubElement(propstat, "d:status").text = "HTTP/1.1 200 OK"

    add_response(base_url, path)

    if is_dir:
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            item_url = base_url.rstrip("/") + "/" + item
            add_response(item_url, item_path)

    return tostring(response, encoding="utf-8", xml_declaration=True)


class ReadOnlyWebDAVHandler(BaseHTTPRequestHandler):
    server_version = "MinimalWebDAV/0.1"

    def do_GET(self):
        return self.serve_file()

    def do_HEAD(self):
        return self.serve_file(head_only=True)

    def serve_file(self, head_only=False):
        path = self.translate_path(self.path)
        if os.path.isfile(path):
            self.send_response(200)
            self.send_header("Content-Length", os.path.getsize(path))
            self.send_header("Content-Type", "application/octet-stream")
            self.end_headers()
            if not head_only:
                with open(path, "rb") as f:
                    self.wfile.write(f.read())

        elif os.path.isdir(path):
            if head_only:
                self.send_response(200)
                self.send_header("Content-Type", "text/html; charset=utf-8")
                self.end_headers()
                return

            listing = self.generate_directory_listing(path, self.path)
            encoded = listing.encode("utf-8")
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.send_header("Content-Length", str(len(encoded)))
            self.end_headers()
            self.wfile.write(encoded)

        else:
            self.send_error(404)

    def generate_directory_listing(self, dir_path, request_path):
        title = f"Index of {request_path}"
        entries = []

        try:
            entries = sorted(os.listdir(dir_path))
        except OSError:
            return "<html><body><h1>Permission Denied</h1></body></html>"

        lines = [f"<html><head><title>{title}</title></head><body>"]
        lines.append(f"<h1>{title}</h1>")
        lines.append("<ul>")

        if request_path.strip("/") != "":
            parent = os.path.dirname(request_path.rstrip("/"))
            lines.append(f'<li><a href="{parent or "/"}">../</a></li>')

        for name in entries:
            full_path = os.path.join(dir_path, name)
            display = name + "/" if os.path.isdir(full_path) else name
            href = os.path.join(request_path, name)
            if os.path.isdir(full_path) and not href.endswith("/"):
                href += "/"
            lines.append(f'<li><a href="{href}">{display}</a></li>')

        lines.append("</ul></body></html>")
        return "\n".join(lines)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header("Allow", ", ".join(ALLOWED_METHODS))
        self.end_headers()

    def do_PROPFIND(self):
        path = self.translate_path(self.path)
        base_url = urlparse(self.path).path
        if not os.path.exists(path):
            self.send_error(404)
            return
        xml = make_propfind_response(path, base_url)
        self.send_response(207)
        self.send_header("Content-Type", "application/xml; charset=utf-8")
        self.send_header("Content-Length", str(len(xml)))
        self.end_headers()
        self.wfile.write(xml)

    def translate_path(self, req_path):
        rel_path = unquote(urlparse(req_path).path.lstrip("/"))
        full_path = os.path.join(self.server.serve_directory, rel_path)
        return os.path.abspath(full_path)

    def method_not_allowed(self):
        self.send_response(405)
        self.send_header("Allow", ", ".join(ALLOWED_METHODS))
        self.end_headers()

    def do_PUT(self): self.method_not_allowed()
    def do_DELETE(self): self.method_not_allowed()
    def do_MKCOL(self): self.method_not_allowed()
    def do_MOVE(self): self.method_not_allowed()
    def do_COPY(self): self.method_not_allowed()
    def do_PROPPATCH(self): self.method_not_allowed()


class CustomHTTPServer(HTTPServer):
    def __init__(self, server_address, RequestHandlerClass, serve_directory):
        super().__init__(server_address, RequestHandlerClass)
        self.serve_directory = serve_directory


@click.command()
@click.option("--port", default=8888, help="Port to listen on", show_default=True)
@click.option("--directory", default=".", type=click.Path(exists=True, file_okay=False),
              help="Directory to serve", show_default=True)
def main(port, directory):
    """Start a minimal read-only WebDAV server."""

    def open_firewall():
        try:
            subprocess.run(["firewall-cmd", "--add-port={}/tcp".format(port)],
                           check=True)
            click.echo(f"‚úÖ Opened firewalld port {port} (runtime only)")
        except subprocess.CalledProcessError as e:
            click.echo(f"‚ùå Failed to open firewalld port: {e}", err=True)
            sys.exit(1)

    def close_firewall():
        try:
            subprocess.run(["firewall-cmd",
                            "--remove-port={}/tcp".format(port)],
                           check=True)
            click.echo(f"üõë Closed firewalld port {port}")
        except subprocess.CalledProcessError as e:
            click.echo(f"‚ùå Failed to close firewalld port: {e}", err=True)

    def signal_handler(sig, frame):
        click.echo("\nüõë Ctrl+C received, shutting down...")
        sys.exit(0)

    def print_network_urls():
        click.echo("üåç WebDAV server is accessible at:")
        for iface, addr_list in psutil.net_if_addrs().items():
            for addr in addr_list:
                if addr.family != socket.AF_INET or \
                   addr.address.startswith("127."):
                    continue
                url = f"http://{addr.address}:{port}/"
                click.echo(f"  {iface}: {url}")
        click.echo()

    signal.signal(signal.SIGINT, signal_handler)
    os.chdir(directory)
    open_firewall()
    print_network_urls()
    click.echo(f"üìÇ Serving directory: {os.path.abspath(directory)} (read-only)\n")

    server = CustomHTTPServer(("0.0.0.0", port), ReadOnlyWebDAVHandler, serve_directory=directory)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        close_firewall()


if __name__ == "__main__":
    main()
